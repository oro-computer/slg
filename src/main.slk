package slg;

import { Args } from "std/args";
import std::interfaces;
import std::runtime::mem;
import std::runtime::posix::fs;
import std::runtime::posix::io;

import { Config, parse_cli, print_help, print_version } from "./slg/cli.slk";
import { run_auto } from "./slg/engine.slk";
import { BufferU8 } from "./slg/buf.slk";
import { dup, memcpy, memmem } from "./slg/os.slk";

async fn run_cfg (cfg: Config) -> int {
  if cfg.help {
    print_help();
    return 0;
  }
  if cfg.version {
    print_version();
    return 0;
  }
  let code: int = await run_auto(cfg);
  return code;
}

/**
 * `slg` (Silk Line Grep) â€” fast recursive file + pattern search.
 *
 * This is the program entrypoint used by `silk build` for the `slg` target.
 *
 * @param argc: int Argument count (C `argc`).
 * @param argv: u64 Pointer to argv (C `argv`).
 * @returns int Exit code (0: match found, 1: no match, 2: error).
 */
export async fn main (argc: int, argv: u64) -> int {
  let args: Args = Args.init(argc, argv);
  let cfg_opt: Config? = parse_cli(args);
  let code: int = match (cfg_opt) {
    Some(cfg) => await run_cfg(cfg),
    None => 2,
  };
  return code;
}

/**
 * Minimal `argv` owner for end-to-end CLI tests.
 *
 * This allocates:
 * - one `char**` pointer list (`argv`),
 * - one NUL-terminated allocation per argument (`argv[i]`).
 */
struct ArgvOwned {
  argc: int,
  argv: u64,
}

/**
 * Load a little-endian 32-bit integer from `ptr + offset`.
 */
fn load_i32_le (ptr: u64, offset: i64) -> int {
  let b0: u64 = std::runtime::mem::load_u8(ptr, offset + 0) as u64;
  let b1: u64 = std::runtime::mem::load_u8(ptr, offset + 1) as u64;
  let b2: u64 = std::runtime::mem::load_u8(ptr, offset + 2) as u64;
  let b3: u64 = std::runtime::mem::load_u8(ptr, offset + 3) as u64;
  let v: u64 = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
  return v as int;
}

/**
 * Allocate a NUL-terminated C string copy of `s`.
 *
 * @returns u64 Pointer on success, otherwise 0 on OOM.
 */
fn cstr_alloc (s: string) -> u64 {
  let len: i64 = std::runtime::mem::string_len(s);
  if len < 0 {
    return 0;
  }
  let ptr: u64 = std::runtime::mem::alloc(len + 1);
  if ptr == 0 {
    return 0;
  }

  let src: u64 = std::runtime::mem::string_ptr(s);
  let _ = memcpy(ptr, src, len);
  std::runtime::mem::store_u8(ptr, len, 0);
  return ptr;
}

/**
 * Free the first `count` `argv[i]` allocations in a `char**` list.
 */
fn argv_free_partial (argv: u64, count: int) -> void {
  if argv == 0 || count <= 0 {
    return;
  }
  var i: int = 0;
  while i < count {
    let p: u64 = std::runtime::mem::load_u64(argv, (i * 8) as i64);
    std::runtime::mem::free(p);
    i = i + 1;
  }
}

/**
 * Return the `index`th vararg `string`, or `None` when out of range.
 *
 * Note: Silk varargs are currently represented as `len` plus a fixed set of
 * fields (`a0..a31`), so indexing is manually unrolled here.
 */
fn argv_vararg_at (index: int, ...args: string) -> string? {
  if index < 0 || index >= args.len {
    return None;
  }
  if index == 0 { return Some(args.a0); }
  if index == 1 { return Some(args.a1); }
  if index == 2 { return Some(args.a2); }
  if index == 3 { return Some(args.a3); }
  if index == 4 { return Some(args.a4); }
  if index == 5 { return Some(args.a5); }
  if index == 6 { return Some(args.a6); }
  if index == 7 { return Some(args.a7); }
  if index == 8 { return Some(args.a8); }
  if index == 9 { return Some(args.a9); }
  if index == 10 { return Some(args.a10); }
  if index == 11 { return Some(args.a11); }
  if index == 12 { return Some(args.a12); }
  if index == 13 { return Some(args.a13); }
  if index == 14 { return Some(args.a14); }
  if index == 15 { return Some(args.a15); }
  if index == 16 { return Some(args.a16); }
  if index == 17 { return Some(args.a17); }
  if index == 18 { return Some(args.a18); }
  if index == 19 { return Some(args.a19); }
  if index == 20 { return Some(args.a20); }
  if index == 21 { return Some(args.a21); }
  if index == 22 { return Some(args.a22); }
  if index == 23 { return Some(args.a23); }
  if index == 24 { return Some(args.a24); }
  if index == 25 { return Some(args.a25); }
  if index == 26 { return Some(args.a26); }
  if index == 27 { return Some(args.a27); }
  if index == 28 { return Some(args.a28); }
  if index == 29 { return Some(args.a29); }
  if index == 30 { return Some(args.a30); }
  if index == 31 { return Some(args.a31); }
  return None;
}

/**
 * Allocate an owned argv list for end-to-end CLI tests.
 *
 * This allocates:
 * - one `char**` pointer list (`argv`),
 * - one NUL-terminated allocation per argument (`argv[i]`).
 */
fn argv_alloc (...args: string) -> ArgvOwned? {
  if args.len <= 0 {
    return None;
  }
  if args.len > 32 {
    return None;
  }
  let argc: int = args.len;
  // Allocate a `char**` pointer list with a conventional trailing NULL slot.
  let argv: u64 = std::runtime::mem::alloc(((argc + 1) * 8) as i64);
  if argv == 0 {
    return None;
  }
  std::runtime::mem::store_u64(argv, (argc * 8) as i64, 0);

  var i: int = 0;
  while i < argc {
    let s_opt: string? = argv_vararg_at(i, args);
    let s: string = s_opt ?? "";

    let p: u64 = cstr_alloc(s);
    if p == 0 {
      argv_free_partial(argv, i);
      std::runtime::mem::free(argv);
      return None;
    }
    std::runtime::mem::store_u64(argv, (i * 8) as i64, p);
    i = i + 1;
  }

  return Some(ArgvOwned{ argc: argc, argv: argv });
}

impl ArgvOwned as std::interfaces::Drop {
  public fn drop (mut self: &ArgvOwned) -> void {
    argv_free_partial(self.argv, self.argc);
    std::runtime::mem::free(self.argv);
    self.argc = 0;
    self.argv = 0;
  }
}

/**
 * Read all bytes from `fd` into a growable buffer.
 */
fn read_all_fd (fd: int) -> BufferU8? {
  let b_opt: BufferU8? = BufferU8.init(4096);
  if b_opt == None {
    return None;
  }
  let mut b: BufferU8 = b_opt ?? BufferU8.empty();

  let chunk_size: i64 = 4096;
  let chunk: u64 = std::runtime::mem::alloc(chunk_size);
  if chunk == 0 {
    b.drop();
    return None;
  }

  while true {
    let n: int = std::runtime::posix::io::read(fd, chunk, chunk_size);
    if n <= 0 {
      break;
    }
    let err = b.push_ptr_len(chunk, n as i64);
    if err != None {
      std::runtime::mem::free(chunk);
      b.drop();
      return None;
    }
  }

  std::runtime::mem::free(chunk);
  return Some(b);
}

/**
 * View the buffer bytes as a `string` without UTF-8 validation.
 */
fn buffer_as_string (b: &BufferU8) -> string {
  let bytes = b.as_bytes();
  if bytes.len <= 0 || bytes.ptr == 0 {
    return "";
  }
  let len_i64: i64 = bytes.len;
  let max_i32: i64 = 2147483647 as i64;
  let len: int = if len_i64 > max_i32 { max_i32 as int } else { len_i64 as int };
  return std::runtime::mem::string_from_ptr_len(bytes.ptr, len);
}

/**
 * Return whether `hay` contains `needle` as a byte substring.
 */
fn contains (hay: string, needle: string) -> bool {
  let n_len: i64 = std::runtime::mem::string_len(needle);
  if n_len <= 0 {
    return true;
  }
  let h_ptr: u64 = std::runtime::mem::string_ptr(hay);
  let h_len: i64 = std::runtime::mem::string_len(hay);
  let n_ptr: u64 = std::runtime::mem::string_ptr(needle);
  return memmem(h_ptr, h_len, n_ptr, n_len) != 0;
}

/**
 * Captured stdout output from `slg` for end-to-end tests.
 */
struct Capture {
  code: int,
  out: BufferU8,
}

impl Capture as std::interfaces::Drop {
  /**
   * Release captured output.
   *
   * Note: we avoid calling methods on `mut` field-access receivers in the
   * current subset by moving the field into a local, dropping it, then
   * resetting the field to an inert value.
   */
  public fn drop (mut self: &Capture) -> void {
    let mut out: BufferU8 = self.out;
    self.out = BufferU8.empty();
    out.drop();
    self.code = 0;
  }
}

/**
 * Run `slg` while capturing stdout to memory (used by end-to-end tests).
 */
async fn capture_stdout_run_cfg (cfg: Config) -> Capture? {
  // Create a pipe for capturing stdout.
  let fds_ptr: u64 = std::runtime::mem::alloc(8);
  if fds_ptr == 0 {
    return None;
  }
  let prc: int = std::runtime::posix::io::pipe(fds_ptr) as int;
  if prc != 0 {
    std::runtime::mem::free(fds_ptr);
    return None;
  }
  let rfd: int = load_i32_le(fds_ptr, 0);
  let wfd: int = load_i32_le(fds_ptr, 4);
  std::runtime::mem::free(fds_ptr);

  // Save stdout, then redirect fd=1 into the pipe.
  let saved: int = dup(1);
  if saved < 0 {
    let _ = std::runtime::posix::fs::close(rfd);
    let _ = std::runtime::posix::fs::close(wfd);
    return None;
  }
  let _ = std::runtime::posix::io::dup2(wfd, 1);
  let _ = std::runtime::posix::fs::close(wfd);

  // Run.
  let code: int = await run_cfg(cfg);

  // Restore stdout (closes the pipe write end).
  let _ = std::runtime::posix::io::dup2(saved, 1);
  let _ = std::runtime::posix::fs::close(saved);

  // Drain captured output.
  let out_opt: BufferU8? = read_all_fd(rfd);
  let _ = std::runtime::posix::fs::close(rfd);
  if out_opt == None {
    return None;
  }
  let out: BufferU8 = out_opt ?? BufferU8.empty();
  return Some(Capture{ code: code, out: out });
}

/**
 * Run `slg` with stdout redirected to a non-writable fd.
 *
 * This is used by end-to-end tests to ensure output failures are treated as
 * errors (exit code 2) and trigger early-stop cancellation in parallel mode.
 */
async fn broken_stdout_run_cfg (cfg: Config) -> int? {
  // Create a pipe, then (intentionally) dup the read end onto stdout.
  let fds_ptr: u64 = std::runtime::mem::alloc(8);
  if fds_ptr == 0 {
    return None;
  }
  let prc: int = std::runtime::posix::io::pipe(fds_ptr) as int;
  if prc != 0 {
    std::runtime::mem::free(fds_ptr);
    return None;
  }
  let rfd: int = load_i32_le(fds_ptr, 0);
  let wfd: int = load_i32_le(fds_ptr, 4);
  std::runtime::mem::free(fds_ptr);

  // Save stdout, then redirect fd=1 to the read end (writes will fail).
  let saved: int = dup(1);
  if saved < 0 {
    let _ = std::runtime::posix::fs::close(rfd);
    let _ = std::runtime::posix::fs::close(wfd);
    return None;
  }
  let _ = std::runtime::posix::io::dup2(rfd, 1);
  let _ = std::runtime::posix::fs::close(rfd);
  let _ = std::runtime::posix::fs::close(wfd);

  // Run.
  let code: int = await run_cfg(cfg);

  // Restore stdout.
  let _ = std::runtime::posix::io::dup2(saved, 1);
  let _ = std::runtime::posix::fs::close(saved);
  return Some(code);
}

test "slg e2e - help is descriptive" {
  let av_opt: ArgvOwned? = argv_alloc("slg", "--help");
  assert(av_opt != None, "argv alloc failed");
  let mut av: ArgvOwned = av_opt ?? ArgvOwned{ argc: 0, argv: 0 };

  let args: Args = Args.init(av.argc, av.argv);
  let cfg_opt: Config? = parse_cli(args);
  assert(cfg_opt != None, "parse_cli should succeed");

  let cap_opt: Capture? = match (cfg_opt) {
    Some(cfg) => await capture_stdout_run_cfg(cfg),
    None => None,
  };
  assert(cap_opt != None, "capture failed");
  let mut cap: Capture = cap_opt ?? Capture{ code: 2, out: BufferU8.empty() };

  assert(cap.code == 0, "expected exit code 0");
  let out_s: string = buffer_as_string(cap.out);
  assert(contains(out_s, "USAGE:"), "help output should include USAGE");
  assert(contains(out_s, "EXAMPLES:"), "help output should include EXAMPLES");
  assert(contains(out_s, "--jobs"), "help output should include --jobs");
  assert(contains(out_s, "--max-workers"), "help output should include --max-workers");
  assert(contains(out_s, "--parallel-files"), "help output should include --parallel-files");
  assert(contains(out_s, "--no-parallel"), "help output should include --no-parallel");

  cap.drop();
  av.drop();
}

test "slg e2e - --files can run in parallel" {
  let av_opt: ArgvOwned? = argv_alloc("slg", "--files", "--parallel-files", "--jobs=4", "testdata/basic");
  assert(av_opt != None, "argv alloc failed");
  let mut av: ArgvOwned = av_opt ?? ArgvOwned{ argc: 0, argv: 0 };

  let args: Args = Args.init(av.argc, av.argv);
  let cfg_opt: Config? = parse_cli(args);
  assert(cfg_opt != None, "parse_cli should succeed");

  let cap_opt: Capture? = match (cfg_opt) {
    Some(cfg) => await capture_stdout_run_cfg(cfg),
    None => None,
  };
  assert(cap_opt != None, "capture failed");
  let mut cap: Capture = cap_opt ?? Capture{ code: 2, out: BufferU8.empty() };

  assert(cap.code == 0, "expected exit code 0");
  let out_s: string = buffer_as_string(cap.out);
  assert(contains(out_s, "testdata/basic/a.txt"), "expected a file path in output");
  assert(contains(out_s, "testdata/basic/sub/b.txt"), "expected a file path in output");
  assert(!contains(out_s, ".hidden.txt"), "should not include hidden files by default");

  cap.drop();
  av.drop();
}

test "slg e2e - output failure is an error" {
  let av_opt: ArgvOwned? = argv_alloc("slg", "--files", "--parallel-files", "--jobs=4", "testdata/basic");
  assert(av_opt != None, "argv alloc failed");
  let mut av: ArgvOwned = av_opt ?? ArgvOwned{ argc: 0, argv: 0 };

  let args: Args = Args.init(av.argc, av.argv);
  let cfg_opt: Config? = parse_cli(args);
  assert(cfg_opt != None, "parse_cli should succeed");

  let code_opt: int? = match (cfg_opt) {
    Some(cfg) => await broken_stdout_run_cfg(cfg),
    None => None,
  };
  assert(code_opt != None, "run should return a code");
  let code: int = code_opt ?? 0;
  assert(code == 2, "expected exit code 2 when stdout is not writable");

  av.drop();
}

test "slg e2e - fixed search finds a match" {
  let av_opt: ArgvOwned? = argv_alloc("slg", "-F", "TODO", "testdata/basic");
  assert(av_opt != None, "argv alloc failed");
  let mut av: ArgvOwned = av_opt ?? ArgvOwned{ argc: 0, argv: 0 };

  let args: Args = Args.init(av.argc, av.argv);
  let cfg_opt: Config? = parse_cli(args);
  assert(cfg_opt != None, "parse_cli should succeed");

  let cap_opt: Capture? = match (cfg_opt) {
    Some(cfg) => await capture_stdout_run_cfg(cfg),
    None => None,
  };
  assert(cap_opt != None, "capture failed");
  let mut cap: Capture = cap_opt ?? Capture{ code: 2, out: BufferU8.empty() };

  assert(cap.code == 0, "expected exit code 0 (match found)");
  let out_s: string = buffer_as_string(cap.out);
  assert(contains(out_s, "testdata/basic/a.txt"), "expected matched file path in output");
  assert(contains(out_s, "TODO"), "expected match text in output");

  cap.drop();
  av.drop();
}

test "slg e2e - --jobs 1 forces single-threaded" {
  let av_opt: ArgvOwned? = argv_alloc("slg", "--jobs=1", "-F", "TODO", "testdata/basic");
  assert(av_opt != None, "argv alloc failed");
  let mut av: ArgvOwned = av_opt ?? ArgvOwned{ argc: 0, argv: 0 };

  let args: Args = Args.init(av.argc, av.argv);
  let cfg_opt: Config? = parse_cli(args);
  assert(cfg_opt != None, "parse_cli should succeed");

  let cap_opt: Capture? = match (cfg_opt) {
    Some(cfg) => await capture_stdout_run_cfg(cfg),
    None => None,
  };
  assert(cap_opt != None, "capture failed");
  let mut cap: Capture = cap_opt ?? Capture{ code: 2, out: BufferU8.empty() };

  assert(cap.code == 0, "expected exit code 0 (match found)");
  let out_s: string = buffer_as_string(cap.out);
  assert(contains(out_s, "testdata/basic/a.txt"), "expected matched file path in output");
  assert(contains(out_s, "TODO"), "expected match text in output");

  cap.drop();
  av.drop();
}

test "slg e2e - concurrency values are clamped" {
  let av_opt: ArgvOwned? =
    argv_alloc("slg", "--jobs=999", "--max-workers=999", "-F", "TODO", "testdata/basic");
  assert(av_opt != None, "argv alloc failed");
  let mut av: ArgvOwned = av_opt ?? ArgvOwned{ argc: 0, argv: 0 };

  let args: Args = Args.init(av.argc, av.argv);
  let cfg_opt: Config? = parse_cli(args);
  assert(cfg_opt != None, "parse_cli should succeed");

  let Some(cfg) = cfg_opt else {
    assert(false, "config should exist");
    av.drop();
    return;
  };

  // Current implementation limit: 1 orchestrator + 8 worker slots.
  assert(cfg.jobs == 9, "expected --jobs to clamp to 9");
  assert(cfg.max_workers == 8, "expected --max-workers to clamp to 8");

  av.drop();
}

test "slg e2e - hidden files require --hidden" {
  // Without --hidden: no matches.
  let av1_opt: ArgvOwned? = argv_alloc("slg", "-F", "needle_hidden", "testdata/basic");
  assert(av1_opt != None, "argv alloc failed");
  let mut av1: ArgvOwned = av1_opt ?? ArgvOwned{ argc: 0, argv: 0 };

  let args1: Args = Args.init(av1.argc, av1.argv);
  let cfg1_opt: Config? = parse_cli(args1);
  assert(cfg1_opt != None, "parse_cli should succeed");
  let cap1_opt: Capture? = match (cfg1_opt) {
    Some(cfg) => await capture_stdout_run_cfg(cfg),
    None => None,
  };
  assert(cap1_opt != None, "capture failed");
  let mut cap1: Capture = cap1_opt ?? Capture{ code: 2, out: BufferU8.empty() };

  assert(cap1.code == 1, "expected exit code 1 (no match)");
  let out1: string = buffer_as_string(cap1.out);
  assert(!contains(out1, ".hidden.txt"), "should not search hidden files by default");
  assert(!contains(out1, "needle_hidden"), "should not match hidden content by default");

  cap1.drop();
  av1.drop();

  // With --hidden: match appears.
  let av2_opt: ArgvOwned? = argv_alloc("slg", "-F", "--hidden", "needle_hidden", "testdata/basic");
  assert(av2_opt != None, "argv alloc failed");
  let mut av2: ArgvOwned = av2_opt ?? ArgvOwned{ argc: 0, argv: 0 };

  let args2: Args = Args.init(av2.argc, av2.argv);
  let cfg2_opt: Config? = parse_cli(args2);
  assert(cfg2_opt != None, "parse_cli should succeed");
  let cap2_opt: Capture? = match (cfg2_opt) {
    Some(cfg) => await capture_stdout_run_cfg(cfg),
    None => None,
  };
  assert(cap2_opt != None, "capture failed");
  let mut cap2: Capture = cap2_opt ?? Capture{ code: 2, out: BufferU8.empty() };

  assert(cap2.code == 0, "expected exit code 0 (match found)");
  let out2: string = buffer_as_string(cap2.out);
  assert(contains(out2, ".hidden.txt"), "expected hidden file path in output");
  assert(contains(out2, "needle_hidden"), "expected hidden match text in output");

  cap2.drop();
  av2.drop();
}

test "slg e2e - --files lists searchable files" {
  let av_opt: ArgvOwned? = argv_alloc("slg", "--files", "testdata/basic");
  assert(av_opt != None, "argv alloc failed");
  let mut av: ArgvOwned = av_opt ?? ArgvOwned{ argc: 0, argv: 0 };

  let args: Args = Args.init(av.argc, av.argv);
  let cfg_opt: Config? = parse_cli(args);
  assert(cfg_opt != None, "parse_cli should succeed");

  let cap_opt: Capture? = match (cfg_opt) {
    Some(cfg) => await capture_stdout_run_cfg(cfg),
    None => None,
  };
  assert(cap_opt != None, "capture failed");
  let mut cap: Capture = cap_opt ?? Capture{ code: 2, out: BufferU8.empty() };

  assert(cap.code == 0, "expected exit code 0");
  let out_s: string = buffer_as_string(cap.out);
  assert(contains(out_s, "testdata/basic/a.txt"), "expected a.txt in file list");
  assert(contains(out_s, "testdata/basic/sub/b.txt"), "expected b.txt in file list");
  assert(!contains(out_s, ".hidden.txt"), "hidden files should be skipped unless --hidden");

  cap.drop();
  av.drop();
}

test "slg e2e - ignore files are respected" {
  // With ignore files enabled (default): ignored paths should be skipped.
  let av1_opt: ArgvOwned? = argv_alloc("slg", "--files", "testdata/ignore");
  assert(av1_opt != None, "argv alloc failed");
  let mut av1: ArgvOwned = av1_opt ?? ArgvOwned{ argc: 0, argv: 0 };

  let args1: Args = Args.init(av1.argc, av1.argv);
  let cfg1_opt: Config? = parse_cli(args1);
  assert(cfg1_opt != None, "parse_cli should succeed");

  let cap1_opt: Capture? = match (cfg1_opt) {
    Some(cfg) => await capture_stdout_run_cfg(cfg),
    None => None,
  };
  assert(cap1_opt != None, "capture failed");
  let mut cap1: Capture = cap1_opt ?? Capture{ code: 2, out: BufferU8.empty() };

  assert(cap1.code == 0, "expected exit code 0");
  let out1: string = buffer_as_string(cap1.out);
  assert(contains(out1, "testdata/ignore/a.txt"), "expected unignored file in list");
  assert(contains(out1, "testdata/ignore/keep.log"), "expected negated file in list");
  assert(contains(out1, "testdata/ignore/sub/anchored.txt"), "expected anchored rule to not apply in subdir");

  assert(!contains(out1, "testdata/ignore/ignored.txt"), "expected ignored file to be skipped");
  assert(!contains(out1, "testdata/ignore/a.log"), "expected glob-ignored file to be skipped");
  assert(!contains(out1, "testdata/ignore/anchored.txt"), "expected anchored ignored file to be skipped");
  assert(!contains(out1, "testdata/ignore/deep.txt"), "expected globstar-ignored file to be skipped");
  assert(!contains(out1, "testdata/ignore/sub/deep.txt"), "expected globstar-ignored file to be skipped");
  assert(!contains(out1, "testdata/ignore/ignored_dir/x.txt"), "expected ignored directory to be skipped");

  cap1.drop();
  av1.drop();

  // With ignore files disabled: previously ignored paths should re-appear.
  let av2_opt: ArgvOwned? = argv_alloc("slg", "--files", "--no-ignore-files", "testdata/ignore");
  assert(av2_opt != None, "argv alloc failed");
  let mut av2: ArgvOwned = av2_opt ?? ArgvOwned{ argc: 0, argv: 0 };

  let args2: Args = Args.init(av2.argc, av2.argv);
  let cfg2_opt: Config? = parse_cli(args2);
  assert(cfg2_opt != None, "parse_cli should succeed");

  let cap2_opt: Capture? = match (cfg2_opt) {
    Some(cfg) => await capture_stdout_run_cfg(cfg),
    None => None,
  };
  assert(cap2_opt != None, "capture failed");
  let mut cap2: Capture = cap2_opt ?? Capture{ code: 2, out: BufferU8.empty() };

  assert(cap2.code == 0, "expected exit code 0");
  let out2: string = buffer_as_string(cap2.out);
  assert(contains(out2, "testdata/ignore/ignored.txt"), "expected ignored file to re-appear with --no-ignore-files");
  assert(contains(out2, "testdata/ignore/a.log"), "expected glob-ignored file to re-appear with --no-ignore-files");
  assert(contains(out2, "testdata/ignore/anchored.txt"), "expected anchored ignored file to re-appear with --no-ignore-files");
  assert(contains(out2, "testdata/ignore/deep.txt"), "expected globstar-ignored file to re-appear with --no-ignore-files");
  assert(contains(out2, "testdata/ignore/sub/deep.txt"), "expected globstar-ignored file to re-appear with --no-ignore-files");
  assert(contains(out2, "testdata/ignore/ignored_dir/x.txt"), "expected ignored directory contents to re-appear with --no-ignore-files");

  cap2.drop();
  av2.drop();
}
