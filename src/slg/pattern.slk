module slg::pattern;

import std::interfaces;
import std::limits;
import std::regex;
import std::result;
import std::runtime::mem;

import { memchr, memmem } from "./os.slk";

/**
 * Concrete `Result` specialization for runtime regex compilation.
 *
 * We use a named alias so we can call static helper methods like
 * `ReCompileResult.unwrap_or(...)`.
 */
type ReCompileResult = std::result::Result(std::regex::RegExp, std::regex::CompileFailed);

/**
 * Pattern matching mode.
 */
export enum PatternKind {
  Fixed,
  Regex,
}

/**
 * A single match location within a line (byte offsets).
 */
export struct Match {
  start: i64,
  end: i64,
}

/**
 * A compiled search pattern.
 *
 * Notes:
 * - When `kind == Fixed`, `regex` stays empty.
 * - When `kind == Regex`, `needle` stores the original pattern text.
 */
export struct Pattern {
  kind: PatternKind,
  needle: string,
  ignore_case: bool,
  // Compiled regex bytecode (owned).
  regex: std::regex::RegExp,
}

impl Pattern as std::interfaces::Drop {
  /**
   * Reset the value.
   */
  public fn drop (mut self: &Pattern) -> void {
    self.kind = PatternKind::Fixed;
    self.needle = "";
    self.ignore_case = false;
    self.regex = std::regex::RegExp.empty();
  }
}

export enum PatternErrorKind {
  EmptyPattern,
  RegexCompileFailed,
  InvalidInput,
}

export error PatternFailed {
  code: int,
  detail: int,
}

impl PatternFailed {
  public fn kind (self: &PatternFailed) -> PatternErrorKind {
    if self.code == 1 { return PatternErrorKind::EmptyPattern; }
    if self.code == 2 { return PatternErrorKind::RegexCompileFailed; }
    return PatternErrorKind::InvalidInput;
  }
}

fn failed (kind: PatternErrorKind, detail: int) -> PatternFailed {
  let code: int = match (kind) {
    PatternErrorKind::EmptyPattern => 1,
    PatternErrorKind::RegexCompileFailed => 2,
    PatternErrorKind::InvalidInput => 0,
  };
  return PatternFailed{ code: code, detail: detail };
}

/**
 * `Pattern.compile(...)` result.
 *
 * We use a local result enum for explicit, allocation-free error handling.
 *
 * Historical note: older hosted-backend snapshots rejected some generic
 * applications in type positions; this no longer reproduces in this workspace
 * as of 2026-02-07.
 */
export enum PatternResult {
  Ok(Pattern),
  Err(PatternFailed),
}

impl PatternResult {
  public fn is_ok (self: &PatternResult) -> bool {
    return match self {
      Ok(_) => true,
      Err(_) => false,
    };
  }

  public fn is_err (self: &PatternResult) -> bool {
    return match self {
      Ok(_) => false,
      Err(_) => true,
    };
  }
}

fn is_ascii_upper (b: u8) -> bool {
  return b >= 65 && b <= 90;
}

fn ascii_lower (b: u8) -> u8 {
  if is_ascii_upper(b) {
    return b + 32;
  }
  return b;
}

fn eq_ascii_case_insensitive (a_ptr: u64, b_ptr: u64, n: i64) -> bool {
  if n <= 0 {
    return true;
  }
  var i: i64 = 0;
  while i < n {
    let a: u8 = ascii_lower(std::runtime::mem::load_u8(a_ptr, i));
    let b: u8 = ascii_lower(std::runtime::mem::load_u8(b_ptr, i));
    if a != b {
      return false;
    }
    i = i + 1;
  }
  return true;
}

fn is_regex_meta (b: u8) -> bool {
  // Common regex metacharacters:
  //   . ^ $ * + ? ( ) [ ] { } | \
  return
    b == 46  || // '.'
    b == 94  || // '^'
    b == 36  || // '$'
    b == 42  || // '*'
    b == 43  || // '+'
    b == 63  || // '?'
    b == 40  || // '('
    b == 41  || // ')'
    b == 91  || // '['
    b == 93  || // ']'
    b == 123 || // '{'
    b == 125 || // '}'
    b == 124 || // '|'
    b == 92;    // '\\'
}

fn is_literal_regex (text: string) -> bool {
  let n: i64 = std::runtime::mem::string_len(text);
  if n <= 0 {
    return false;
  }

  let ptr: u64 = std::runtime::mem::string_ptr(text);
  var i: i64 = 0;
  while i < n {
    let b: u8 = std::runtime::mem::load_u8(ptr, i);
    if is_regex_meta(b) {
      return false;
    }
    i = i + 1;
  }
  return true;
}

fn next_fixed_case_sensitive (hay_ptr: u64, hay_len: i64, needle_ptr: u64, needle_len: i64, start: i64) -> Match? {
  if needle_len <= 0 {
    return None;
  }
  if start < 0 || start > hay_len {
    return None;
  }
  if hay_len < needle_len {
    return None;
  }
  let tail_ptr: u64 = hay_ptr + (start as u64);
  let tail_len: i64 = hay_len - start;

  if needle_len == 1 {
    let b: u8 = std::runtime::mem::load_u8(needle_ptr, 0);
    let p: u64 = memchr(tail_ptr, b as int, tail_len);
    if p == 0 {
      return None;
    }
    let off: i64 = (p - hay_ptr) as i64;
    return Some(Match{ start: off, end: off + 1 });
  }

  let p: u64 = memmem(tail_ptr, tail_len, needle_ptr, needle_len);
  if p == 0 {
    return None;
  }
  let off: i64 = (p - hay_ptr) as i64;
  return Some(Match{ start: off, end: off + needle_len });
}

fn next_fixed_ascii_case_insensitive (hay_ptr: u64, hay_len: i64, needle_ptr: u64, needle_len: i64, start: i64) -> Match? {
  if needle_len <= 0 {
    return None;
  }
  if start < 0 || start > hay_len {
    return None;
  }
  if hay_len < needle_len {
    return None;
  }
  if needle_len == 1 {
    let n0: u8 = std::runtime::mem::load_u8(needle_ptr, 0);
    let lower: u8 = ascii_lower(n0);
    let upper: u8 = if lower >= 97 && lower <= 122 { lower - 32 } else { lower };

    let tail_ptr: u64 = hay_ptr + (start as u64);
    let tail_len: i64 = hay_len - start;

    let p1: u64 = memchr(tail_ptr, lower as int, tail_len);
    let p2: u64 = if upper == lower { 0 } else { memchr(tail_ptr, upper as int, tail_len) };

    if p1 == 0 && p2 == 0 {
      return None;
    }

    let p: u64 =
      if p1 == 0 { p2 }
      else if p2 == 0 { p1 }
      else if p1 < p2 { p1 }
      else { p2 };

    let off: i64 = (p - hay_ptr) as i64;
    return Some(Match{ start: off, end: off + 1 });
  }

  let last: i64 = hay_len - needle_len;
  if start > last {
    return None;
  }

  let n0: u8 = std::runtime::mem::load_u8(needle_ptr, 0);
  let lower0: u8 = ascii_lower(n0);
  let upper0: u8 = if lower0 >= 97 && lower0 <= 122 { lower0 - 32 } else { lower0 };

  // Scan for the first byte via libc `memchr`, then verify candidates.
  var i: i64 = start;
  while i <= last {
    let tail_ptr: u64 = hay_ptr + (i as u64);
    let tail_len: i64 = hay_len - i;

    let p1: u64 = memchr(tail_ptr, lower0 as int, tail_len);
    let p2: u64 = if upper0 == lower0 { 0 } else { memchr(tail_ptr, upper0 as int, tail_len) };

    if p1 == 0 && p2 == 0 {
      return None;
    }

    let p: u64 =
      if p1 == 0 { p2 }
      else if p2 == 0 { p1 }
      else if p1 < p2 { p1 }
      else { p2 };

    let cand: i64 = (p - hay_ptr) as i64;
    if cand > last {
      return None;
    }

    let a_ptr: u64 = hay_ptr + (cand as u64);
    if eq_ascii_case_insensitive(a_ptr, needle_ptr, needle_len) {
      return Some(Match{ start: cand, end: cand + needle_len });
    }

    i = cand + 1;
  }
  return None;
}

/**
 * Compile a search pattern from CLI flags.
 *
 * @param text: string Raw pattern string.
 * @param fixed: bool When true, treat `text` as a literal byte substring.
 * @param ignore_case: bool When true, use case-insensitive matching.
 * @returns PatternResult Compiled pattern or `PatternFailed`.
 */
export fn compile (text: string, fixed: bool, ignore_case: bool) -> PatternResult {
  let n: i64 = std::runtime::mem::string_len(text);
  if n <= 0 {
    return Err(failed(PatternErrorKind::EmptyPattern, 0));
  }

  // Fast path: when the pattern contains no regex metacharacters, regex
  // semantics are identical to a fixed substring search. In that case we can
  // skip regex compilation and use the fixed matcher (case-sensitive only).
  let effective_fixed: bool =
    fixed || (!ignore_case && is_literal_regex(text));

  if effective_fixed {
    return Ok(Pattern{
      kind: PatternKind::Fixed,
      needle: text,
      ignore_case: ignore_case,
      regex: std::regex::RegExp.empty(),
    });
  }

  let flags: string = if ignore_case { "i" } else { "" };

  // Note: prefer `std::result::Result.unwrap_or(...)` instead of destructuring
  // the regex compile result directly. This avoids a known class of "by-value
  // enum payload" move-tracking bugs in the hosted subset that can lead to
  // use-after-free crashes when the owning `RegExp` gets dropped unexpectedly.
  let r: ReCompileResult = std::regex::RegExp.compile(text, flags);
  if r.is_err() {
    let e_opt: std::regex::CompileFailed? = ReCompileResult.err_value(r);
    let e: std::regex::CompileFailed = e_opt ?? std::regex::CompileFailed{ code: 0 };
    return Err(failed(PatternErrorKind::RegexCompileFailed, e.code));
  }

  let re: std::regex::RegExp = ReCompileResult.unwrap_or(r, std::regex::RegExp.empty());
  return Ok(Pattern{
    kind: PatternKind::Regex,
    needle: text,
    ignore_case: ignore_case,
    regex: move re,
  });
}

/**
 * Return the first match at or after `start` within `line`.
 *
 * @param p: &Pattern Compiled pattern.
 * @param line: string Line to search.
 * @param start: i64 Byte start offset.
 * @returns Match? Match location, or `None`.
 */
export fn next_match (p: &Pattern, line: string, start: i64) -> Match? {
  let ptr: u64 = std::runtime::mem::string_ptr(line);
  let len: i64 = std::runtime::mem::string_len(line);

  if start < 0 || start > len {
    return None;
  }

  if p.kind == PatternKind::Fixed {
    let needle_ptr: u64 = std::runtime::mem::string_ptr(p.needle);
    let needle_len: i64 = std::runtime::mem::string_len(p.needle);
    if p.ignore_case {
      return next_fixed_ascii_case_insensitive(ptr, len, needle_ptr, needle_len, start);
    }
    return next_fixed_case_sensitive(ptr, len, needle_ptr, needle_len, start);
  }

  // Regex.
  if len < 0 || len > (std::limits::I32_MAX as i64) {
    return None;
  }
  let r: std::regex::ExecResult = std::regex::search(p.regex.as_regexp(), line, start as int);
  if r.code != std::regex::EXEC_MATCH {
    return None;
  }

  let s: i64 = r.start as i64;
  let e: i64 = r.end as i64;
  if e < s {
    return None;
  }
  return Some(Match{ start: s, end: e });
}

/**
 * Return whether `line` matches `p`.
 */
export fn is_match (p: &Pattern, line: string) -> bool {
  return next_match(p, line, 0) != None;
}

test "slg::pattern - fixed case-sensitive" {
  let p_r: PatternResult = compile("aba", true, false);
  assert(p_r.is_ok(), "compile should succeed");
  let p: Pattern = match (p_r) {
    Ok(v) => v,
    Err(_) => Pattern{ kind: PatternKind::Fixed, needle: "", ignore_case: false, regex: std::regex::RegExp.empty() },
  };

  let m0: Match? = next_match(p, "xxabaxxaba", 0);
  assert(m0 != None, "expected match");
  let m: Match = m0 ?? Match{ start: -1, end: -1 };
  assert(m.start == 2 && m.end == 5, "unexpected match location");
}

test "slg::pattern - fixed ignore-case (ASCII)" {
  let p_r: PatternResult = compile("AbC", true, true);
  assert(p_r.is_ok(), "compile should succeed");
  let p: Pattern = match (p_r) {
    Ok(v) => v,
    Err(_) => Pattern{ kind: PatternKind::Fixed, needle: "", ignore_case: true, regex: std::regex::RegExp.empty() },
  };

  let m0: Match? = next_match(p, "--abc--", 0);
  assert(m0 != None, "expected match");
  let m: Match = m0 ?? Match{ start: -1, end: -1 };
  assert(m.start == 2 && m.end == 5, "unexpected match location");
}

test "slg::pattern - regex basic" {
  let p_r: PatternResult = compile("T.DO", false, false);
  assert(p_r.is_ok(), "compile should succeed");
  let p: Pattern = match (p_r) {
    Ok(v) => v,
    Err(_) => Pattern{ kind: PatternKind::Fixed, needle: "", ignore_case: false, regex: std::regex::RegExp.empty() },
  };

  let m0: Match? = next_match(p, "xxTODOyy", 0);
  assert(m0 != None, "expected match");
  let m: Match = m0 ?? Match{ start: -1, end: -1 };
  assert(m.start == 2 && m.end == 6, "unexpected match location");
}
